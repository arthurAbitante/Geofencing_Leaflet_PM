<!DOCTYPE html>
<html>
<head>
	<title>Leaflet Draw</title>
	<meta charset="utf-8">
	 <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- Load Leaflet from CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css"
    integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
    crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"
    integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg=="
    crossorigin=""></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet.pm@latest/dist/leaflet.pm.css" />
    <script src="https://unpkg.com/leaflet.pm@latest/dist/leaflet.pm.min.js"></script>
    <!--biblioteca para checar distancia entre pontos de latitudes e longitudes-->
    <script src="https://cdn.rawgit.com/hayeswise/Leaflet.PointInPolygon/v1.0.0/wise-leaflet-pip.js"></script>

    <!--Biblioteca Leaflet 3D-->
    <script src="http://www.webglearth.com/v2/api.js"></script>
<style type="text/css">
	    body { margin:0; padding:0; }
    #mapid { position: absolute; top:0; bottom:0; right:0; left:0; }
</style>

</head>
<body>
<div id="mapid"></div>

</body>

<script type="text/javascript">

  var mymap = L.map('mapid').setView([-20.76125, -44.28316], 5);

  L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);
 // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
   // attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
  //}).addTo(mymap);

  //L.marker(item.latlng, {pmIgnore: true}).addTo(mymap);

  mymap.pm.addControls({
  	position: 'topleft',
  	editMode: true,
    drawPolyline: false
  });

 
  var marker;
  var group;
  var shape;
  var allShapes = {
      length: 0,
      id: new Array(),
      elements: new Array(),

      addElem: function addElem(elem){
        this.elements.push.call(this.elements, elem);
      },
    
      updateElem: function update(index, target){
        //this.elements.splice.call(this.id, 1, elem);
        this.elements[index]._latlngs[0] = [];
        //console.log(allShapes.elements[indexValue]._latlngs[0]);
        this.elements[index]._latlngs[0].push(target);
      },
      removeElem: function remove(index, target){
        this.elements[index]._latlngs[0] = [];
      },
      idShape: function idShape(elem){
        this.id.push(elem);
      }
  };

  //representa o valor das formas
  var valuesShape = {};
  //representa o id da forma
  var idShape = new Array();
  //representa se está dentro ou fora da cerca
  var valueFence = new Array();
  //representa a forma retangular
  var rectangle = new Array();
  //representa a forma poligonal que é adaptada para varias formas
  var polygon = new Array();
  //representa o circulo
  var circle = new Array();

  //precisará da representação do CircleMarker semelhante ao circulo

//checar parameto no circulo
  L.Circle.include({
  contains: function (latLng) {
    return this.getLatLng().distanceTo(latLng) < this.getRadius();
  }
});

 mymap.pm.globalRemovalEnabled();
 mymap.pm.Draw.Cut.enable({
    allowSelfIntersection: false
 });

//FUNCAO REMOVER
mymap.on('pm:remove', (re) => {
  var indexValue = allShapes.id.indexOf(re.layer._leaflet_id);

  allShapes.removeElem(indexValue, re.layer._latlngs[0]);
  //allShapes.updateElem(indexValue, ed.target._latlngs[0]);
  //Aqui verifica qual é o tipo de forma que foi adicionada e depois limpa o array
  //porém como está sendo adaptado para multiplas formas, então tera que ser reajustado.
  if(shape === 'rectangle'){
      rectangle = [];
  }
  if(shape === 'polygon'){
      polygon = [];
  }
  if(shape === 'circle'){
      valuesShape = [];
  }
});

//----------------------------QUANDO CORTAR
mymap.on('pm:cut', (c) => {
  var result = c.layer._leaflet_id - 1;

  if(shape === 'rectangle'){
    rectangle = [];
    shape = 'polygon';
     
  }
  polygon = [];
  for(var i = 0; i < c.layer._layers[result]._latlngs[0].length; i++){
    polygon.push([c.layer._layers[result]._latlngs[0][i].lat, c.layer._layers[result]._latlngs[0][i].lng]);
  }
});

//cada shape adicionado em allShapes, ele possui uma parte com o id e outr com as lat e lngs, então 
//deve ser percorrido ambos para saber qual deve alterar e qual não deve
//pegar o index do id
//usar o index do id para pegar o indice do das layers

 mymap.on('pm:create', (e) => {
    console.log(e.shape);
    if(e.shape === 'Rectangle'){
      shape = 'rectangle';

      console.log(allShapes);
    
      for(var i = 0; i < e.layer._latlngs[0].length; i++){
        rectangle.push([e.layer._latlngs[0][i].lat, e.layer._latlngs[0][i].lng]); 

        if(rectangle.length >= e.layer._latlngs[0].length){
          valuesShape = L.rectangle(rectangle);
          allShapes.addElem(valuesShape);
          allShapes.idShape(e.layer._leaflet_id);
          rectangle = [];
        }
        console.log(allShapes);
      }
      //QUANDO EDITAR
      e.layer.on('pm:edit', (ed) => {
       // console.log(ed.target._leaflet_id);
       // console.log(ed.target._latlngs);
      //  for(var j = 0; j < allShapes.length; j++){
        //    console.log(allShapes[j]);
       // }  
        var indexValue = allShapes.id.indexOf(ed.target._leaflet_id);
        console.log("Valor do indice: " + indexValue);

        allShapes.updateElem(indexValue, ed.target._latlngs[0]);
        console.log(allShapes);
        //ele edita porem nao funciona corretamente


      });

//---------------------------------------------QUANDO ARRASTAR
      e.layer.on('pm:dragend', (de) => {
        console.log(de.target._leaflet_id);
        rectangle = [];

        for(var i = 0; i < de.target._latlngs[0].length; i++){
          rectangle.push([de.target._latlngs[0][i].lat, de.target._latlngs[0][i].lng]);
        }
       });

    //poligono
    }else if(e.shape === 'Polygon'){
      shape = 'polygon';
      for(var i = 0; i < e.layer._latlngs[0].length; i++){
        polygon.push([e.layer._latlngs[0][i].lat, e.layer._latlngs[0][i].lng]);
        if(polygon.length >= e.layer._latlngs[0].length){
          valuesShape = L.polygon(polygon);
          allShapes.addElem(valuesShape);
          allShapes.idShape(e.layer._leaflet_id);
          polygon = [];
        }
      }

      //quando editar
      e.layer.on('pm:edit', (ed) => {
        polygon = [];
        for(var i = 0; i < ed.target._latlngs[0].length; i++){
          polygon.push([ed.target._latlngs[0][i].lat, ed.target._latlngs[0][i].lng]);
        }  
      
      });

      //---------------------------------QUANDO ARRASTAR
      e.layer.on('pm:dragend', (de) => {
        polygon = [];

        for(var i = 0; i < de.target._latlngs[0].length; i++){
          polygon.push([de.target._latlngs[0][i].lat, de.target._latlngs[0][i].lng]);
        }
      });

  //a forma do circulo é diferente de outros para ser checado a cerca dele
  //
  }else if(e.shape === 'Circle'){
    shape = 'circle';

    valuesShape = L.circle([e.layer._latlng.lat, e.layer._latlng.lng], e.layer._mRadius);
    allShapes.addElem(valuesShape);
    allShapes.idShape(e.layer._leaflet_id);

    //vai ser preciso adicionar no array de allShapes em updateElem
    e.layer.on('pm:edit', (ed) => {
      valuesShape = [];
      valuesShape = L.circle([ed.target._latlng.lat, ed.target._latlng.lng], ed.target._mRadius);
    });
    
    //vai ser preciso adicionar no array de allShapes em updateElem
    e.layer.on('pm:dragend', (de) => {
      valuesShape = [];
      valuesShape = L.circle([de.target._latlng.lat, de.target._latlng.lng], de.target._mRadius);
    });

  }else if(e.shape === 'Marker'){
    marker = L.marker([e.layer._latlng.lat, e.layer._latlng.lng]).addTo(mymap);
    
    allFences();
  }else{
    alert("Não há forma");
  }
});

//Função que verifica a cerca e se ela está dentro ou fora.
function allFences(){
  var outFence = 0;
  for(var i = 0; i < allShapes.elements.length; i++){
    //verifica se o marcador está presente no array de formas e como são multiplas formas, ele verifica todas as formas que estão
    //adicionadas no mapa
    var valueFences = allShapes.elements[i].contains(marker.getLatLng());
    
    if(valueFences === false){
      outFence = outFence + 1;
    }
  }
  console.log(allShapes);
  console.log(outFence);

  if(outFence === allShapes.elements.length){
    alert('Está fora da cerca');
  }

}


</script>


</html>